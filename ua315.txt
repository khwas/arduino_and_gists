#include <Wire.h> // Use Wire according to arcticle https://garretlabs.wordpress.com/2014/03/18/the-dark-side-of-porting-arduino-sketches-on-intel-galileo-part-one/
#include <Math.h> 

int RESET_PIN = 8;
int DC_PIN = 9;
int CS_PIN = 7;
int MOSI_PIN = 2;
int MISO_PIN = 12;
int SCK_PIN = 3;

//TFT resolution 240*320
#define MIN_X	0
#define MIN_Y	0
#define MAX_X	319
#define MAX_Y	239

class MyPrint: public Print
{
  public: word X, Y = 0;
  public: word S = 2;
    size_t write(uint8_t character) {
      drawChar(X, Y, character, 0xFFCF, 0x0017, S);
      X += 6 * S;
      return 0;
    }
};

uint32_t latchValue;
MyPrint mPrint = MyPrint();
byte ID1 = 0;
byte ID2 = 0;
byte ID3 = 0;


void setup() {
  // put your setup code here, to run once:
  pinMode(RESET_PIN, OUTPUT_FAST);
  pinMode(DC_PIN, OUTPUT_FAST);
  pinMode(CS_PIN, OUTPUT_FAST);
  digitalWrite(CS_PIN, LOW);           // CS pin is unchanged all the time ever since
  pinMode(MOSI_PIN, OUTPUT_FAST);
  pinMode(SCK_PIN, OUTPUT_FAST);
  digitalWrite(SCK_PIN, LOW);          // Clock pin initial state is low
  pinMode(MISO_PIN, INPUT_FAST);
  latchValue = fastGpioDigitalLatch();
  TFTinit();
  ID1 = readRegister(0xd3, 1);
  ID2 = readRegister(0xd3, 2);
  ID3 = readRegister(0xd3, 3);
  Wire.begin();
}

void loop() {

  byte r80 = readAD5933(0x80);
  byte r81;
  r80 = 0x90 | (r80 & 0x0F); // read temperature command
  writeAD5933(0x80, r80);    // send the command

  writeAD5933FrequencyHz((double)5000.0);
  writeAD5933IncrementHz((double)0.0);
  writeAD5933IncrementsN((word) 0);
  writeAD5933SettlingCnt(1000);

  writeAD5933(0x80, 0xB0);   // standby mode command
  displayData();
  writeAD5933(0x81, 0x10);   // reset command
  displayData();
  writeAD5933(0x80, 0x10);   // initialize with start frequency
  displayData();
  writeAD5933(0x80, 0x20);   // start sweep
  for (byte centisec = 0; centisec < 5; centisec++) {
    displayData();
    byte r8F = readAD5933(0x8F) & 0x07;
    if ((r8F & 0x02) != 0) break;
    delay(10);
  }
  displayData();
  
  word color = random(0, 0xFFFF);

/*
  for (byte x = 0; x < 21; x++) {
    for (byte y = 0; y < 16; y++) {
      word c = y * 21 + x + 0;
      if (c < 256) {
        drawChar(x * 6 * 2 + 60, y * 8 * 2 + 20, y * 21 + x + 0, 0xFFCF, 0x0017, 2);
      }
    }
  }
  // put your main code here, to run repeatedly:
  word XL = random(MIN_X, MAX_X);
  word XR = random(MIN_X, MAX_X);
  word YU = random(MIN_Y, MAX_Y);
  word YD = random(MIN_Y, MAX_Y);

  if (random(0, 100) > 75)
  {
    word W = random(1, MAX_X - XL + 1);
    word H = random(1, MAX_Y - YU + 1);
    fillRectangle(XL, YU, W, H, color);
  } else
  {
    drawLine(XL, XR, YU, YD, color);
  }
  */
  /*
  drawLine(0, 0, MAX_X, 0, color);
  drawLine(0, MAX_Y, MAX_X, MAX_Y, color);
  drawLine(0, 0, 0, MAX_Y, color);
  drawLine(MAX_X, 0, MAX_X, MAX_Y, color);

  drawLine(1, 1, MAX_X-1, 1, color);
  drawLine(1, MAX_Y-1, MAX_X-1, MAX_Y-1, color);
  drawLine(1, 1, 1, MAX_Y-1, color);
  drawLine(MAX_X-1, 1, MAX_X-1, MAX_Y-1, color);

  drawLine(0, 0, MAX_X, MAX_Y, color);
  drawLine(1, 0, MAX_X, MAX_Y-1, color);
  drawLine(0, 1, MAX_X-1, MAX_Y, color);
  drawLine(MAX_X, 0, 0, MAX_Y, color);
  drawLine(MAX_X-1, 0, 0, MAX_Y-1, color);
  drawLine(MAX_X, 1, 1, MAX_Y, color);
  */
}

void displayData()
{
  mPrint.X = 0; mPrint.Y =   0; mPrint.print("Ctl: ");  mPrint.print(formatHEX8(readAD5933(0x80))); mPrint.print(formatHEX8(readAD5933(0x81)));
  double frequencyHz = readAD5933FrequencyHz();
  double incrementHz = readAD5933IncrementHz();
  mPrint.X = 0; mPrint.Y =  16; mPrint.print("fHz: ");  mPrint.print(frequencyHz, 6);   mPrint.print("               ");
  mPrint.X = 0; mPrint.Y =  32; mPrint.print("iHz: ");  mPrint.print(incrementHz, 6);   mPrint.print("               ");
  word le511 = readAD5933IncrementsN();
  mPrint.X = 0; mPrint.Y =  48; mPrint.print("Inc: ");  mPrint.print(le511);            mPrint.print("               ");
  word le2044 =  readAD5933SettlingCnt();
  mPrint.X = 0; mPrint.Y =  64; mPrint.print("Stl: ");  mPrint.print(le2044);           mPrint.print("               ");
  byte r8F = readAD5933(0x8F) & 0x07;
  mPrint.X = 0; mPrint.Y =  80; mPrint.print("Sta: ");  
  if ((r8F & 0x01) != 0) mPrint.print("T=Y "); else mPrint.print("T=N ");
  if ((r8F & 0x02) != 0) mPrint.print("D=Y "); else mPrint.print("D=N ");
  if ((r8F & 0x04) != 0) mPrint.print("S=Y "); else mPrint.print("S=N ");
  double TempC = readAD5933TemperatureC();
  mPrint.X = 0; mPrint.Y =  96; mPrint.print("T");  mPrint.write(248); mPrint.print("C: "); mPrint.print(TempC, 5); mPrint.print("               ");
  double Re = readAD5933RealData();
  double Im = readAD5933ImaginaryData();
  mPrint.X = 0; mPrint.Y = 112; mPrint.print("zRe: ");  mPrint.print(Re); mPrint.print("               ");
  mPrint.X = 0; mPrint.Y = 128; mPrint.print("zIm: ");  mPrint.print(Im); mPrint.print("               ");
  double Zx = sqrt(sq(Re) + sq(Im));
  mPrint.X = 0; mPrint.Y = 144; mPrint.print("Abs: ");  mPrint.print(Zx, 3); mPrint.print("               ");
  double An = (atan2(Im, Re)/M_PI)*(double)180.0;
  mPrint.X = 0; mPrint.Y = 160; mPrint.print("Ang: ");  mPrint.print(An, 3); mPrint.print("               ");
}


void drawLine(int x0, int y0, int x1, int y1, word color)
{
  int dx =  abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
  int dy = -abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
  int err = dx + dy, e2; // our error val.

  for (;;) {
    drawPixel(x0, MAX_Y - y0, color);
    if (x0 == x1 && y0 == y1) break;

    // Line calculation using the Bresenham algorithm.
    e2 = 2 * err;
    if (e2 > dy) {
      err += dy;
      x0 += sx;
    }
    if (e2 < dx) {
      err += dx;
      y0 += sy;
    }
  }
}

char formatHEX8Result[3];
char* formatHEX8(byte value)
{
  sprintf(formatHEX8Result, "%02X", value);
  formatHEX8Result[2] = 0;
  return formatHEX8Result;
}

double readAD5933FrequencyHz()
{
   long triple = 0;
   long single = 0;
   single = readAD5933(0x82);
   triple = triple | (single << 16);
   single = readAD5933(0x83);
   triple = triple | (single << 8);
   single = readAD5933(0x84);
   triple = triple | (single << 0);
   double result = (double)4000000.0*((double)triple/(double)134217728.0); // 2^27;
   return result;
}

void writeAD5933FrequencyHz(double valueHz)
{
   double phaseSpeed = valueHz / (double)4000000.0;
   double controlDbl = phaseSpeed * (double)134217728.0;
   long triple = (long)controlDbl;
   byte single = 0;
   single = (triple >> 16) & 0xFF;
   writeAD5933(0x82, single);
   single = (triple >> 8) & 0xFF;
   writeAD5933(0x83, single);
   single = (triple >> 0) & 0xFF;
   writeAD5933(0x84, single);
}

double readAD5933IncrementHz()
{
   long triple = 0;
   long single = 0;
   single = readAD5933(0x85);
   triple = triple | (single << 16);
   single = readAD5933(0x86);
   triple = triple | (single << 8);
   single = readAD5933(0x87);
   triple = triple | (single << 0);
   double result = (double)4000000.0*((double)triple/(double)134217728.0); // 2^27;
   return result;
}

void writeAD5933IncrementHz(double valueHz)
{
   double phaseSpeed = valueHz / (double)4000000.0;
   double controlDbl = phaseSpeed * (double)134217728.0;
   long triple = (long)controlDbl;
   byte single = 0;
   single = (triple >> 16) & 0xFF;
   writeAD5933(0x85, single);
   single = (triple >> 8) & 0xFF;
   writeAD5933(0x86, single);
   single = (triple >> 0) & 0xFF;
   writeAD5933(0x87, single);
}

word readAD5933IncrementsN()
{
   word result = 0;
   word single = 0;
   single = readAD5933(0x88);
   result = result | ((single & 0x01) << 8);
   single = readAD5933(0x89);
   result = result | ((single & 0xFF) << 0);
   return result;
}

void writeAD5933IncrementsN(word le511)
{
   byte single = 0;
   single = (le511 >> 8) & 0x01;
   writeAD5933(0x88, single);
   single = (le511 >> 0) & 0xFF;
   writeAD5933(0x89, single);
}

word readAD5933SettlingCnt()
{
   word r8A = readAD5933(0x8A);
   word r8B = readAD5933(0x8B);
   word result = r8B | ((r8A & 0x01) << 8);
   if ((r8A & 0x06) == 0x06) {
     result = result * 4;
   } else 
   if ((r8A & 0x06) == 0x02)
   {
     result = result * 2;
   };
   return result;
}

void writeAD5933SettlingCnt(word le2044)
{
   byte r8A = 0;
   byte r8B = 0;
   if (le2044 > 1022) 
   { 
     r8A = 0x06 | ((le2044 >> 10) & 0x01); // use x4 multiplier and occupy 1 MSb
     r8B = (le2044 >> 2) & 0xFF;           // occupy 8 LSb
   } else
   if (le2044 > 511) 
   { 
     r8A = 0x02 | ((le2044 >> 9) & 0x01); // use x2 multiplier and occupy 1 MSb
     r8B = (le2044 >> 1) & 0xFF;          // occupy 8 LSb
   } else
   {
     r8A = 0x00 | ((le2044 >> 8) & 0x01); // use x1 multiplier and occupy 1 MSb
     r8B = (le2044 >> 0) & 0xFF;          // occupy 8 LSb
   }
   writeAD5933(0x8A, r8A);
   writeAD5933(0x8B, r8B);
}

double readAD5933TemperatureC()
{
   long r92 = readAD5933(0x92);
   r92 = r92 << 26;
   long r93 = readAD5933(0x93);
   r93 = r93 << 18;
   long ival = r92 | r93;
   ival = ival / 262144;
   double result = (double)ival * (double)0.03125;
   return result;
}

double readAD5933RealData()
{
   long r94 = readAD5933(0x94);
   r94 = r94 << 24;
   long r95 = readAD5933(0x95);
   r95 = r95 << 16;
   long ival = r94 | r95;
   ival = ival / 65536;
   double result = (double)ival;
   return result;
}

double readAD5933ImaginaryData()
{
   long r96 = readAD5933(0x96);
   r96 = r96 << 24;
   long r97 = readAD5933(0x97);
   r97 = r97 << 16;
   long ival = r96 | r97;
   ival = ival / 65536;
   double result = (double)ival;
   return result;
}

void commandAD5933( )
{
}

byte readAD5933(byte registerNumber)
{
  byte twoBytes[2];
  twoBytes[0] = 0xB0; // Pointer Command
  twoBytes[1] = registerNumber; // Register 0x80..0x9X
  Wire.beginTransmission(0x0D); // 0x0D is I2C 7 bit address of AD5933
  Wire.write(twoBytes, 2);
  Wire.endTransmission();
  
  Wire.requestFrom(0x0D, 1, true); // 0x0D is I2C 7 bit address of AD5933
  byte result = Wire.read(); // read one byte
  return result;
}

void writeAD5933(byte registerNumber, byte value)
{
  byte twoBytes[2];
  twoBytes[0] = registerNumber; // Register 0x80..0x9X
  twoBytes[1] = value; // value
  Wire.beginTransmission(0x0D); // 0x0D is I2C 7 bit address of AD5933
  Wire.write(twoBytes, 2);
  Wire.endTransmission();
}

void drawPixel(word X, word Y, word color)
{
  sendCMD(0x2A);
  sendData16(Y);
  sendData16(Y);
  sendCMD(0x2B);
  sendData16(X);
  sendData16(X);
  sendCMD(0x2C);
  digitalWrite(DC_PIN, HIGH); // TFT_DC_HIGH;
  shiftWord(color);
}

void shiftByte(byte data)
{
  latchValue &= ~GPIO_FAST_IO3;                   // Set clock pin low
  fastGpioDigitalWriteDestructive(latchValue);
  for (int i = 7; i >= 0; i--)
  {
    uint32_t wasLatchValue = latchValue;
    byte mask = 0x01 << i;
    if ((data & mask) > 0)
    {
      latchValue |= GPIO_FAST_IO2;
    } else
    {
      latchValue &= ~GPIO_FAST_IO2;
    }
    if (wasLatchValue != latchValue) {
      fastGpioDigitalWriteDestructive(latchValue);
    }
    latchValue |= GPIO_FAST_IO3;
    fastGpioDigitalWriteDestructive(latchValue);
    latchValue &= ~GPIO_FAST_IO3;
    fastGpioDigitalWriteDestructive(latchValue);
  }
}

void shiftWord(word data)
{
  latchValue &= ~GPIO_FAST_IO3;
  fastGpioDigitalWriteDestructive(latchValue);
  for (int i = 15; i >= 0; i--)
  {
    uint32_t wasLatchValue = latchValue;
    word mask = 0x01 << i;
    if ((data & mask) > 0)
    {
      latchValue |= GPIO_FAST_IO2;
    } else
    {
      latchValue &= ~GPIO_FAST_IO2;
    }
    if (wasLatchValue != latchValue) {
      fastGpioDigitalWriteDestructive(latchValue);
    }
    latchValue |= GPIO_FAST_IO3;
    fastGpioDigitalWriteDestructive(latchValue);
    latchValue &= ~GPIO_FAST_IO3;
    fastGpioDigitalWriteDestructive(latchValue);
  }
}

void sendCMD(byte index)
{
  digitalWrite(DC_PIN, LOW); // TFT_DC_LOW;
  // shift the bits to MOSI
  shiftByte(index);
}


void sendData8(byte data)
{
  digitalWrite(DC_PIN, HIGH); // TFT_DC_HIGH;
  // shift the bits to MOSI
  shiftByte(data);
}

void sendData16(word data)
{
  digitalWrite(DC_PIN, HIGH);
  // shift the bits to MOSI
  shiftWord(data);
}

byte readRegister(byte addr, byte xParameter)
{
  byte result = 0;
  sendCMD(0xD9);                  // ext command
  sendData8(0x10 + xParameter);  // 0x11 is the first Parameter
  digitalWrite(DC_PIN, LOW);      // TFT_DC_LOW;
  shiftByte(addr);
  digitalWrite(DC_PIN, HIGH);     // TFT_DC_HIGH;

  latchValue &= ~GPIO_FAST_IO3; // Set clock pin low
  fastGpioDigitalWriteDestructive(latchValue);
  // sending 8 zero bits and receiving response values from MSB to LSB
  latchValue &= ~GPIO_FAST_IO2;
  byte mask = 0x80;
  for (int i = 7; i >= 0; i--)
  {
    // send a zero
    fastGpioDigitalWriteDestructive(latchValue);
    // receive a bit value
    if (digitalRead(MISO_PIN) != 0)
    {
      result = result | mask;
    }
    // transit clock pin from low to high
    latchValue |= GPIO_FAST_IO3;
    fastGpioDigitalWriteDestructive(latchValue);
    // transit clock pin from high to low
    latchValue &= ~GPIO_FAST_IO3;
    fastGpioDigitalWriteDestructive(latchValue);
    mask = mask >> 1;
  }

  return result;
}

void TFTinit(void)
{
  digitalWrite(CS_PIN, LOW);
  digitalWrite(DC_PIN, HIGH);
  byte TFTDriver = 0;

  digitalWrite(RESET_PIN, LOW);
  delay(10);
  digitalWrite(RESET_PIN, HIGH);
  delay(10);

  // ILI9341
  sendCMD(0xCB);   // Power Control A command
  sendData8(0x39); // 0x39
  sendData8(0x2C); // 0x2C
  sendData8(0x00); // 0x00
  sendData8(0x34); // 0x34 = 1.6V Vcore
  sendData8(0x02); // DDVDH V = 5.4V
  delay(10);

  sendCMD(0xCF);   // Power Control B
  sendData8(0x00); // 0x00
  sendData8(0XC1); // 0x81
  sendData8(0X30); // 0x30
  delay(10);

  sendCMD(0xE8);   // Driver Timing Control
  sendData8(0x85); //
  sendData8(0x00);
  sendData8(0x78);
  delay(1);

  sendCMD(0xE9);   // Driver Timing Control
  sendData8(0x85); //
  sendData8(0x00);
  sendData8(0x78);
  delay(1);

  sendCMD(0xEA);
  sendData8(0x66);
  sendData8(0x00);
  delay(1);

  sendCMD(0xED);
  sendData8(0x55);
  sendData8(0x01);
  sendData8(0X23);
  sendData8(0X01);
  delay(1);

  sendCMD(0xF7);    // Pump Ratio
  sendData8(0x20);  // 2xVCI
  delay(1);

  sendCMD(0xC0);    // Power control 1
  sendData8(0x21);  // VRH[5:0]  4.6V
  delay(1);

  sendCMD(0xC1);    // Power control 2
  sendData8(0x02);  // SAP[2:0];BT[3:0]
  delay(1);

  sendCMD(0xC5);    // VCM control
  sendData8(0x3e);  // VMH Contrast 4.25V
  sendData8(0x28);  // VML Contrast -1.5V
  delay(1);


  sendCMD(0xC7);    // VCOM control 2
  sendData8(0x86);  // VCOMH=VMH-58 VCOML=VML-58
  delay(1);

  sendCMD(0x36);    // Memory Access Control
  sendData8(0xC8);  // C8
  // 48
  // 68 绔栧睆
  // 28
  // E8 妯睆
  delay(1);

  sendCMD(0x3A);    // 16 bit per pixel
  sendData8(0x55);
  delay(1);

  sendCMD(0xB1);    // Frame Rate Control
  sendData8(0x00);  // f osc 1:1
  sendData8(0x1B);  // 70Hz
  delay(1);

  sendCMD(0xB6);    // Display Function Control
  sendData8(0x08);
  sendData8(0x82);
  sendData8(0x27);
  delay(1);

  /*
    sendCMD(0xF2);    // 3Gamma Function Disable
    sendData8(0x00);
    delay(10);

    sendCMD(0x26);    // Gamma curve selected
    sendData8(0x01);  // Gamma curve 1 (G2.2)
    delay(10);

    sendCMD(0xE0);    //Set Gamma
    sendData8(0x0F);
    sendData8(0x31);
    sendData8(0x2B);
    sendData8(0x0C);
    sendData8(0x0E);
    sendData8(0x08);
    sendData8(0x4E);
    sendData8(0xF1);
    sendData8(0x37);
    sendData8(0x07);
    sendData8(0x10);
    sendData8(0x03);
    sendData8(0x0E);
    sendData8(0x09);
    sendData8(0x00);
    delay(10);

    sendCMD(0XE1);    // Set Gamma
    sendData8(0x00);
    sendData8(0x0E);
    sendData8(0x14);
    sendData8(0x03);
    sendData8(0x11);
    sendData8(0x07);
    sendData8(0x31);
    sendData8(0xC1);
    sendData8(0x48);
    sendData8(0x08);
    sendData8(0x0F);
    sendData8(0x0C);
    sendData8(0x31);
    sendData8(0x36);
    sendData8(0x0F);
    delay(10);
  */
  sendCMD(0x11);   // Exit Sleep
  delay(100);

  sendCMD(0x29);   // Display on
  delay(1);
  fillRectangle(  0,   0, 319, 239, 0x0017);
  
/*
  fillRectangle(  0,   0, 319, 239, 0x07E0);
  fillRectangle( 20,  20, 279, 199, 0x001F);
  fillRectangle( 40,  40, 239, 159, 0xF800);
  fillRectangle( 60,  60, 199, 119, 0x001F);
  fillRectangle( 80,  80, 159,  79, 0xF800);
  fillRectangle(100, 100, 119,  39, 0xFFE0);
  */
}

void fillScreen(word XL, word XR, word YU, word YD, word color)
{
  unsigned long XY = 0;

  if (XL > XR)
  {
    XL = XL ^ XR;
    XR = XL ^ XR;
    XL = XL ^ XR;
  }
  if (YU > YD)
  {
    YU = YU ^ YD;
    YD = YU ^ YD;
    YU = YU ^ YD;
  }
  XL = constrain(XL, MIN_X, MAX_X);
  XR = constrain(XR, MIN_X, MAX_X);
  YU = constrain(YU, MIN_Y, MAX_Y);
  YD = constrain(YD, MIN_Y, MAX_Y);

  XY = (XR - XL + 1);
  XY = XY * (YD - YU + 1);

  setRect(XL, XR, YU, YD);
  sendCMD(0x2c);                                                  /* start to write to display ram */
  digitalWrite(DC_PIN, HIGH); // TFT_DC_HIGH;

  for (long i = 0; i < XY; i++)
  {
    shiftWord(color);
  }
}


void fillScreen(void)
{
  setRect(0, MAX_X, 0, MAX_Y);
  sendCMD(0x2C);                                                  /* start to write to display ram */
  digitalWrite(DC_PIN, HIGH); // TFT_DC_HIGH;
  for (word i = 0; i < 38400; i++)
  {
    shiftWord(0xF81F);
    shiftWord(0xF81F);
  }
}

void setRect(word XL, word XR, word YU, word YD)
{
  sendCMD(0x2A);         // Column Command address
  sendData16(YU);        // columns grow from top to bottom
  sendData16(YD);
  sendCMD(0x2B);         // Page Command address
  sendData16(XL);        // pages grow from left to right
  sendData16(XR);
}

//fillRectangle(poX+i*size, poY+f*size, size, size, fgcolor);
void fillRectangle(word poX, word poY, word width, word height, word color)
{
  fillScreen(poX, poX + width, poY, poY + height, color);
}

static const unsigned char font[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x3E, 0x5B, 0x4F, 0x5B, 0x3E, 0x00,
  0x3E, 0x6B, 0x4F, 0x6B, 0x3E, 0x00,
  0x1C, 0x3E, 0x7C, 0x3E, 0x1C, 0x00,
  0x18, 0x3C, 0x7E, 0x3C, 0x18, 0x00,
  0x1C, 0x57, 0x7D, 0x57, 0x1C, 0x00,
  0x1C, 0x5E, 0x7F, 0x5E, 0x1C, 0x00,
  0x00, 0x18, 0x3C, 0x18, 0x00, 0x00,
  0xFF, 0xE7, 0xC3, 0xE7, 0xFF, 0x00,
  0x00, 0x18, 0x24, 0x18, 0x00, 0x00,
  0xFF, 0xE7, 0xDB, 0xE7, 0xFF, 0x00,
  0x30, 0x48, 0x3A, 0x06, 0x0E, 0x00,
  0x26, 0x29, 0x79, 0x29, 0x26, 0x00,
  0x40, 0x7F, 0x05, 0x05, 0x07, 0x00,
  0x40, 0x7F, 0x05, 0x25, 0x3F, 0x00,
  0x5A, 0x3C, 0xE7, 0x3C, 0x5A, 0x00,
  0x7F, 0x3E, 0x1C, 0x1C, 0x08, 0x00,
  0x08, 0x1C, 0x1C, 0x3E, 0x7F, 0x00,
  0x14, 0x22, 0x7F, 0x22, 0x14, 0x00,
  0x5F, 0x5F, 0x00, 0x5F, 0x5F, 0x00,
  0x06, 0x09, 0x7F, 0x01, 0x7F, 0x00,
  0x00, 0x66, 0x89, 0x95, 0x6A, 0x00,
  0x60, 0x60, 0x60, 0x60, 0x60, 0x00,
  0x94, 0xA2, 0xFF, 0xA2, 0x94, 0x00,
  0x08, 0x04, 0x7E, 0x04, 0x08, 0x00,
  0x10, 0x20, 0x7E, 0x20, 0x10, 0x00,
  0x08, 0x08, 0x2A, 0x1C, 0x08, 0x00,
  0x08, 0x1C, 0x2A, 0x08, 0x08, 0x00,
  0x1E, 0x10, 0x10, 0x10, 0x10, 0x00,
  0x0C, 0x1E, 0x0C, 0x1E, 0x0C, 0x00,
  0x30, 0x38, 0x3E, 0x38, 0x30, 0x00,
  0x06, 0x0E, 0x3E, 0x0E, 0x06, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x5F, 0x00, 0x00, 0x00,
  0x00, 0x07, 0x00, 0x07, 0x00, 0x00,
  0x14, 0x7F, 0x14, 0x7F, 0x14, 0x00,
  0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x00,
  0x23, 0x13, 0x08, 0x64, 0x62, 0x00,
  0x36, 0x49, 0x56, 0x20, 0x50, 0x00,
  0x00, 0x08, 0x07, 0x03, 0x00, 0x00,
  0x00, 0x1C, 0x22, 0x41, 0x00, 0x00,
  0x00, 0x41, 0x22, 0x1C, 0x00, 0x00,
  0x2A, 0x1C, 0x7F, 0x1C, 0x2A, 0x00,
  0x08, 0x08, 0x3E, 0x08, 0x08, 0x00,
  0x00, 0x80, 0x70, 0x30, 0x00, 0x00,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x00,
  0x00, 0x00, 0x60, 0x60, 0x00, 0x00,
  0x20, 0x10, 0x08, 0x04, 0x02, 0x00,
  0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00,
  0x00, 0x42, 0x7F, 0x40, 0x00, 0x00,
  0x72, 0x49, 0x49, 0x49, 0x46, 0x00,
  0x21, 0x41, 0x49, 0x4D, 0x33, 0x00,
  0x18, 0x14, 0x12, 0x7F, 0x10, 0x00,
  0x27, 0x45, 0x45, 0x45, 0x39, 0x00,
  0x3C, 0x4A, 0x49, 0x49, 0x31, 0x00,
  0x41, 0x21, 0x11, 0x09, 0x07, 0x00,
  0x36, 0x49, 0x49, 0x49, 0x36, 0x00,
  0x46, 0x49, 0x49, 0x29, 0x1E, 0x00,
  0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
  0x00, 0x40, 0x34, 0x00, 0x00, 0x00,
  0x00, 0x08, 0x14, 0x22, 0x41, 0x00,
  0x14, 0x14, 0x14, 0x14, 0x14, 0x00,
  0x00, 0x41, 0x22, 0x14, 0x08, 0x00,
  0x02, 0x01, 0x59, 0x09, 0x06, 0x00,
  0x3E, 0x41, 0x5D, 0x59, 0x4E, 0x00,
  0x7C, 0x12, 0x11, 0x12, 0x7C, 0x00,
  0x7F, 0x49, 0x49, 0x49, 0x36, 0x00,
  0x3E, 0x41, 0x41, 0x41, 0x22, 0x00,
  0x7F, 0x41, 0x41, 0x41, 0x3E, 0x00,
  0x7F, 0x49, 0x49, 0x49, 0x41, 0x00,
  0x7F, 0x09, 0x09, 0x09, 0x01, 0x00,
  0x3E, 0x41, 0x41, 0x51, 0x73, 0x00,
  0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00,
  0x00, 0x41, 0x7F, 0x41, 0x00, 0x00,
  0x20, 0x40, 0x41, 0x3F, 0x01, 0x00,
  0x7F, 0x08, 0x14, 0x22, 0x41, 0x00,
  0x7F, 0x40, 0x40, 0x40, 0x40, 0x00,
  0x7F, 0x02, 0x1C, 0x02, 0x7F, 0x00,
  0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00,
  0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00,
  0x7F, 0x09, 0x09, 0x09, 0x06, 0x00,
  0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00,
  0x7F, 0x09, 0x19, 0x29, 0x46, 0x00,
  0x26, 0x49, 0x49, 0x49, 0x32, 0x00,
  0x03, 0x01, 0x7F, 0x01, 0x03, 0x00,
  0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00,
  0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00,
  0x3F, 0x40, 0x38, 0x40, 0x3F, 0x00,
  0x63, 0x14, 0x08, 0x14, 0x63, 0x00,
  0x03, 0x04, 0x78, 0x04, 0x03, 0x00,
  0x61, 0x59, 0x49, 0x4D, 0x43, 0x00,
  0x00, 0x7F, 0x41, 0x41, 0x41, 0x00,
  0x02, 0x04, 0x08, 0x10, 0x20, 0x00,
  0x00, 0x41, 0x41, 0x41, 0x7F, 0x00,
  0x04, 0x02, 0x01, 0x02, 0x04, 0x00,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x00,
  0x00, 0x03, 0x07, 0x08, 0x00, 0x00,
  0x20, 0x54, 0x54, 0x78, 0x40, 0x00,
  0x7F, 0x28, 0x44, 0x44, 0x38, 0x00,
  0x38, 0x44, 0x44, 0x44, 0x28, 0x00,
  0x38, 0x44, 0x44, 0x28, 0x7F, 0x00,
  0x38, 0x54, 0x54, 0x54, 0x18, 0x00,
  0x00, 0x08, 0x7E, 0x09, 0x02, 0x00,
  0x18, 0xA4, 0xA4, 0x9C, 0x78, 0x00,
  0x7F, 0x08, 0x04, 0x04, 0x78, 0x00,
  0x00, 0x44, 0x7D, 0x40, 0x00, 0x00,
  0x20, 0x40, 0x40, 0x3D, 0x00, 0x00,
  0x7F, 0x10, 0x28, 0x44, 0x00, 0x00,
  0x00, 0x41, 0x7F, 0x40, 0x00, 0x00,
  0x7C, 0x04, 0x78, 0x04, 0x78, 0x00,
  0x7C, 0x08, 0x04, 0x04, 0x78, 0x00,
  0x38, 0x44, 0x44, 0x44, 0x38, 0x00,
  0xFC, 0x18, 0x24, 0x24, 0x18, 0x00,
  0x18, 0x24, 0x24, 0x18, 0xFC, 0x00,
  0x7C, 0x08, 0x04, 0x04, 0x08, 0x00,
  0x48, 0x54, 0x54, 0x54, 0x24, 0x00,
  0x04, 0x04, 0x3F, 0x44, 0x24, 0x00,
  0x3C, 0x40, 0x40, 0x20, 0x7C, 0x00,
  0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00,
  0x3C, 0x40, 0x30, 0x40, 0x3C, 0x00,
  0x44, 0x28, 0x10, 0x28, 0x44, 0x00,
  0x4C, 0x90, 0x90, 0x90, 0x7C, 0x00,
  0x44, 0x64, 0x54, 0x4C, 0x44, 0x00,
  0x00, 0x08, 0x36, 0x41, 0x00, 0x00,
  0x00, 0x00, 0x77, 0x00, 0x00, 0x00,
  0x00, 0x41, 0x36, 0x08, 0x00, 0x00,
  0x02, 0x01, 0x02, 0x04, 0x02, 0x00,
  0x3C, 0x26, 0x23, 0x26, 0x3C, 0x00,
  0x1E, 0xA1, 0xA1, 0x61, 0x12, 0x00,
  0x3A, 0x40, 0x40, 0x20, 0x7A, 0x00,
  0x38, 0x54, 0x54, 0x55, 0x59, 0x00,
  0x21, 0x55, 0x55, 0x79, 0x41, 0x00,
  0x21, 0x54, 0x54, 0x78, 0x41, 0x00,
  0x21, 0x55, 0x54, 0x78, 0x40, 0x00,
  0x20, 0x54, 0x55, 0x79, 0x40, 0x00,
  0x0C, 0x1E, 0x52, 0x72, 0x12, 0x00,
  0x39, 0x55, 0x55, 0x55, 0x59, 0x00,
  0x39, 0x54, 0x54, 0x54, 0x59, 0x00,
  0x39, 0x55, 0x54, 0x54, 0x58, 0x00,
  0x00, 0x00, 0x45, 0x7C, 0x41, 0x00,
  0x00, 0x02, 0x45, 0x7D, 0x42, 0x00,
  0x00, 0x01, 0x45, 0x7C, 0x40, 0x00,
  0xF0, 0x29, 0x24, 0x29, 0xF0, 0x00,
  0xF0, 0x28, 0x25, 0x28, 0xF0, 0x00,
  0x7C, 0x54, 0x55, 0x45, 0x00, 0x00,
  0x20, 0x54, 0x54, 0x7C, 0x54, 0x00,
  0x7C, 0x0A, 0x09, 0x7F, 0x49, 0x00,
  0x32, 0x49, 0x49, 0x49, 0x32, 0x00,
  0x32, 0x48, 0x48, 0x48, 0x32, 0x00,
  0x32, 0x4A, 0x48, 0x48, 0x30, 0x00,
  0x3A, 0x41, 0x41, 0x21, 0x7A, 0x00,
  0x3A, 0x42, 0x40, 0x20, 0x78, 0x00,
  0x00, 0x9D, 0xA0, 0xA0, 0x7D, 0x00,
  0x39, 0x44, 0x44, 0x44, 0x39, 0x00,
  0x3D, 0x40, 0x40, 0x40, 0x3D, 0x00,
  0x3C, 0x24, 0xFF, 0x24, 0x24, 0x00,
  0x48, 0x7E, 0x49, 0x43, 0x66, 0x00,
  0x2B, 0x2F, 0xFC, 0x2F, 0x2B, 0x00,
  0xFF, 0x09, 0x29, 0xF6, 0x20, 0x00,
  0xC0, 0x88, 0x7E, 0x09, 0x03, 0x00,
  0x20, 0x54, 0x54, 0x79, 0x41, 0x00,
  0x00, 0x00, 0x44, 0x7D, 0x41, 0x00,
  0x30, 0x48, 0x48, 0x4A, 0x32, 0x00,
  0x38, 0x40, 0x40, 0x22, 0x7A, 0x00,
  0x00, 0x7A, 0x0A, 0x0A, 0x72, 0x00,
  0x7D, 0x0D, 0x19, 0x31, 0x7D, 0x00,
  0x26, 0x29, 0x29, 0x2F, 0x28, 0x00,
  0x26, 0x29, 0x29, 0x29, 0x26, 0x00,
  0x30, 0x48, 0x4D, 0x40, 0x20, 0x00,
  0x38, 0x08, 0x08, 0x08, 0x08, 0x00,
  0x08, 0x08, 0x08, 0x08, 0x38, 0x00,
  0x2F, 0x10, 0xC8, 0xAC, 0xBA, 0x00,
  0x2F, 0x10, 0x28, 0x34, 0xFA, 0x00,
  0x00, 0x00, 0x7B, 0x00, 0x00, 0x00,
  0x08, 0x14, 0x2A, 0x14, 0x22, 0x00,
  0x22, 0x14, 0x2A, 0x14, 0x08, 0x00,
  0xAA, 0x00, 0x55, 0x00, 0xAA, 0x00,
  0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x00,
  0xDB, 0x6D, 0xB6, 0xDB, 0x6D, 0x00,
  0x00, 0x00, 0x00, 0xFF, 0x00, 0x00,
  0x10, 0x10, 0x10, 0xFF, 0x00, 0x00,
  0x14, 0x14, 0x14, 0xFF, 0x00, 0x00,
  0x10, 0x10, 0xFF, 0x00, 0xFF, 0x00,
  0x10, 0x10, 0xF0, 0x10, 0xF0, 0x00,
  0x14, 0x14, 0x14, 0xFC, 0x00, 0x00,
  0x14, 0x14, 0xF7, 0x00, 0xFF, 0x00,
  0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00,
  0x14, 0x14, 0xF4, 0x04, 0xFC, 0x00,
  0x14, 0x14, 0x17, 0x10, 0x1F, 0x00,
  0x10, 0x10, 0x1F, 0x10, 0x1F, 0x00,
  0x14, 0x14, 0x14, 0x1F, 0x00, 0x00,
  0x10, 0x10, 0x10, 0xF0, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x1F, 0x10, 0x00,
  0x10, 0x10, 0x10, 0x1F, 0x10, 0x00,
  0x10, 0x10, 0x10, 0xF0, 0x10, 0x00,
  0x00, 0x00, 0x00, 0xFF, 0x10, 0x00,
  0x10, 0x10, 0x10, 0x10, 0x10, 0x00,
  0x10, 0x10, 0x10, 0xFF, 0x10, 0x00,
  0x00, 0x00, 0x00, 0xFF, 0x14, 0x00,
  0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00,
  0x00, 0x00, 0x1F, 0x10, 0x17, 0x00,
  0x00, 0x00, 0xFC, 0x04, 0xF4, 0x00,
  0x14, 0x14, 0x17, 0x10, 0x17, 0x00,
  0x14, 0x14, 0xF4, 0x04, 0xF4, 0x00,
  0x00, 0x00, 0xFF, 0x00, 0xF7, 0x00,
  0x14, 0x14, 0x14, 0x14, 0x14, 0x00,
  0x14, 0x14, 0xF7, 0x00, 0xF7, 0x00,
  0x14, 0x14, 0x14, 0x17, 0x14, 0x00,
  0x10, 0x10, 0x1F, 0x10, 0x1F, 0x00,
  0x14, 0x14, 0x14, 0xF4, 0x14, 0x00,
  0x10, 0x10, 0xF0, 0x10, 0xF0, 0x00,
  0x00, 0x00, 0x1F, 0x10, 0x1F, 0x00,
  0x00, 0x00, 0x00, 0x1F, 0x14, 0x00,
  0x00, 0x00, 0x00, 0xFC, 0x14, 0x00,
  0x00, 0x00, 0xF0, 0x10, 0xF0, 0x00,
  0x10, 0x10, 0xFF, 0x10, 0xFF, 0x00,
  0x14, 0x14, 0x14, 0xFF, 0x14, 0x00,
  0x10, 0x10, 0x10, 0x1F, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xF0, 0x10, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
  0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x00,
  0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00,
  0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x00,
  0x38, 0x44, 0x44, 0x38, 0x44, 0x00,
  0x7C, 0x2A, 0x2A, 0x3E, 0x14, 0x00,
  0x7E, 0x02, 0x02, 0x06, 0x06, 0x00,
  0x02, 0x7E, 0x02, 0x7E, 0x02, 0x00,
  0x63, 0x55, 0x49, 0x41, 0x63, 0x00,
  0x38, 0x44, 0x44, 0x3C, 0x04, 0x00,
  0x40, 0x7E, 0x20, 0x1E, 0x20, 0x00,
  0x06, 0x02, 0x7E, 0x02, 0x02, 0x00,
  0x99, 0xA5, 0xE7, 0xA5, 0x99, 0x00,
  0x1C, 0x2A, 0x49, 0x2A, 0x1C, 0x00,
  0x4C, 0x72, 0x01, 0x72, 0x4C, 0x00,
  0x30, 0x4A, 0x4D, 0x4D, 0x30, 0x00,
  0x30, 0x48, 0x78, 0x48, 0x30, 0x00,
  0xBC, 0x62, 0x5A, 0x46, 0x3D, 0x00,
  0x3E, 0x49, 0x49, 0x49, 0x00, 0x00,
  0x7E, 0x01, 0x01, 0x01, 0x7E, 0x00,
  0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 0x00,
  0x44, 0x44, 0x5F, 0x44, 0x44, 0x00,
  0x40, 0x51, 0x4A, 0x44, 0x40, 0x00,
  0x40, 0x44, 0x4A, 0x51, 0x40, 0x00,
  0x00, 0x00, 0xFF, 0x01, 0x03, 0x00,
  0xE0, 0x80, 0xFF, 0x00, 0x00, 0x00,
  0x08, 0x08, 0x6B, 0x6B, 0x08, 0x00,
  0x36, 0x12, 0x36, 0x24, 0x36, 0x00,
  0x06, 0x0F, 0x09, 0x0F, 0x06, 0x00,
  0x00, 0x00, 0x18, 0x18, 0x00, 0x00,
  0x00, 0x00, 0x10, 0x10, 0x00, 0x00,
  0x30, 0x40, 0xFF, 0x01, 0x01, 0x00,
  0x00, 0x1F, 0x01, 0x01, 0x1E, 0x00,
  0x00, 0x19, 0x1D, 0x17, 0x12, 0x00,
  0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Draw a character
void drawChar(word x, word y, byte c, word fgcolor, word bgcolor, word size)
{
  if ((x >= MAX_X)  || // Clip right
      (y >= MAX_Y)  || // Clip bottom
      ((x + 5) < 0) || // Clip left  TODO: is this correct?
      ((y + 7) < 0))   // Clip top   TODO: is this correct?
    return;

  setRect(x, x + 6 * size - 1, y, y + 8 * size - 1);
  sendCMD(0X2C);
  digitalWrite(DC_PIN, HIGH); // TFT_DC_HIGH;
  word color;

  // 6 times from left to righ do filling of vertical from top to bottom
  for (byte xx = 0; xx < 6; xx++) {
    // duplicate columns
    for (byte xr = 0; xr < size; xr++) {
      // start with mask for 8 repetitions
      byte mask = 0x01;
      for (byte yy = 0; yy < 8; yy++) {
        // compute color
        if (font[c * 6 + xx] & mask) {
          color = fgcolor;
        } else {
          color = bgcolor;
        }
        // output color with duplication top to down
        for (byte yr = 0; yr < size; yr++) {
          shiftWord(color);
        }
        mask = mask << 1;
      } // done with single column
    } // done with duplicates of columns
  } // done with column of duplicates
}

